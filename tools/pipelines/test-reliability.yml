# Copyright (c) Microsoft Corporation and contributors. All rights reserved.
# Licensed under the MIT License.

# test-reliability pipeline (for the purpose of detecting flaky tests)

name: $(Build.BuildId)

trigger: none
pr: none

parameters:
- name: poolBuild
  type: object
  default: Small

- name: poolName
  type: string
  default: Small 1

- name: jobNames
  type: object
  default:
  - Test1
  - Test2
  - Test3
  - Test4
  - Test5

- name: buildDirectory
  type: string
  default: .

- name: taskBuild
  type: string
  default: ci:build

- name: taskBuildDocs
  type: boolean
  default: false

- name: taskLint
  type: boolean
  default: false

- name: taskTest
  type: object
  default:
  - ci:test:mocha
  - ci:test:jest
  - ci:test:realsvc:local
  - ci:test:realsvc:tinylicious
  - ci:test:stress:tinylicious
  - test:copyresults

- name: checkoutSubmodules
  type: boolean
  default: true

- name: namespace
  type: boolean
  default: true

- name: buildNumberInPatch
  type: string
  default: false

- name: publishOverride
  displayName: Publish Override (default = based on branch)
  type: string
  default: default
  values:
    - default
    - skip
    - force

- name: buildToolsVersionToInstall
  displayName: Fluid build tools version (default = installs version in repo)
  type: string
  default: repo

- name: nonScopedPackages
  displayName: Non-scoped packages to publish
  type: object
  default:
  - fluid-framework

- name: releaseBuildOverride
  displayName: Release Build (default = not released)
  type: string
  default: none
  values:
    - none
    - prerelease
    - release

- name: tagName
  type: string
  default: client

- name: includeInternalVersions
  type: boolean
  default: false

schedules:
  - cron: "00 03 * * SUN"
    displayName: Scheduled Tests on Saturday Nights Weekly
    branches:
      include:
      - main
      - next
    always: true

variables:
- group: prague-key-vault
  # We use 'chalk' to colorize output, which auto-detects color support in the
  # running terminal.  The log output shown in Azure DevOps job runs only has
  # basic ANSI color support though, so force that in the pipeline
- name: FORCE_COLOR
  value: 1
- template: templates/include-vars.yml
  parameters:
    publishOverride: ${{ parameters.publishOverride }}
    releaseBuildOverride: ${{ parameters.releaseBuildOverride }}
    buildNumberInPatch: ${{ parameters.buildNumberInPatch }}
    nonScopedPackages: ${{ parameters.nonScopedPackages }}

stages:
  - stage: Build_and_Test
    displayName: Build and Test
    jobs:
      # Job - Build
      - job: build
        displayName: Build
        pool:
          name: ${{ parameters.poolBuild }}
          demands:
          - Agent.Name -equals ${{ parameters.poolName }}
        variables:
          testCoverage: true
          releaseBuildVar: $[variables.releaseBuild]
        steps:
        # Setup
        - checkout: self
          clean: true
          lfs: ${{ parameters.checkoutSubmodules }}
          submodules: ${{ parameters.checkoutSubmodules }}

        - task: Bash@3
          displayName: Parameters
          inputs:
            targetType: 'inline'
            workingDirectory: ${{ parameters.buildDirectory }}
            script: |
              # Show all task group conditions

              echo "
              Pipeline Variables:
                releaseBuild=$(releaseBuildVar)

              Override Parameters:
                publishOverride=${{ parameters.publishOverride }}
                releaseBuildOverride=${{ parameters.releaseBuildOverride }}

              Tasks Parameters:
                BuildDir=${{ parameters.buildDirectory }}
                Build=${{ parameters.taskBuild }}
                Lint=${{ parameters.taskLint }}
                Test=${{ convertToJson(parameters.taskTest) }}
                BuildDoc=${{ parameters.taskBuildDocs }}
                TestCoverage=$(testCoverage)

              Publish Parameters:
                nonScopedPackages=${{ join(', ', parameters.nonScopedPackages) }}

              Computed variables:
                shouldPublish=${{ variables.shouldPublish }}
                componentDetection=${{ variables.componentDetection }}
                publish=${{ variables.publish }}
                canRelease=${{ variables.canRelease }}
                publishNonScopedPackages=${{ variables.publishNonScopedPackages }}
                targetBranchName = $(System.PullRequest.TargetBranch)

                release=$(release)
                "

              # Error checking
              if [[ "$(release)" == "release" ]]; then
                if [[ "${{ variables.canRelease }}" == "False" ]]; then
                  echo "##vso[task.logissue type=error]Invalid branch ${{ variables['Build.SourceBranch'] }} for release"
                  exit -1;
                fi

                if [ -f "lerna.json" ]; then
                  grep -e fluid.*[0-9]-[0-9] `find packages -name 'package.json'`
                else
                  grep -e fluid.*[0-9]-[0-9] `find . -name 'package.json'`
                fi

                if [[ $? == 0 ]]; then
                  echo "##vso[task.logissue type=error]Release shouldn't contain prerelease dependencies"
                  exit -1;
                fi
              fi

              if [[ "$(release)" == "prerelease" ]]; then
                if [[ "${{ parameters.buildNumberInPatch }}" == "true" ]]; then
                  echo "##vso[task.logissue type=error] Prerelease not allow for builds that put build number as the patch version"
                  exit -1;
                fi
              fi

              if [[ "$(release)" != "none" ]] && [[ "$(release)" != "" ]]; then
                if [[ "${{ variables.publish }}" != "True" ]]; then
                  echo "##vso[task.logissue type=error]'$(release)'' is set but package is not published. Either the branch doesn't default to publish or it is skipped."
                  exit -1;
                fi
              fi

        # Install
        - task: UseNode@1
          displayName: Use Node 14.x
          inputs:
            version: 14.x
        - task: Npm@1
          displayName: npm ci
          inputs:
            command: 'custom'
            workingDir: ${{ parameters.buildDirectory }}
            customCommand: 'ci --unsafe-perm'
            customRegistry: 'useNpmrc'

        # Set version
        - template: templates/include-set-package-version.yml
          parameters:
            buildDirectory: ${{ parameters.buildDirectory }}
            buildNumberInPatch: ${{ parameters.buildNumberInPatch }}
            buildToolsVersionToInstall: ${{ parameters.buildToolsVersionToInstall }}
            tagName: ${{ parameters.tagName }}

        # Build
        - ${{ if ne(parameters.taskBuild, 'false') }}:
          - task: Npm@1
            displayName: npm run ${{ parameters.taskBuild }}
            inputs:
              command: 'custom'
              workingDir: ${{ parameters.buildDirectory }}
              customCommand: 'run ${{ parameters.taskBuild }}'

        # Lint
        - ${{ if ne(parameters.taskLint, false) }}:
          - task: Npm@1
            displayName: npm run lint
            inputs:
              command: 'custom'
              workingDir: ${{ parameters.buildDirectory }}
              customCommand: 'run lint'

      - ${{ each jobName in parameters.jobNames }}:
        - job: ${{ jobName }}
          displayName: ${{ jobName }}
          pool:
            name: ${{ parameters.poolBuild }}
            demands:
            - Agent.Name -equals ${{ parameters.poolName }}
          dependsOn: build
          steps:
          # Test
          - ${{ if ne(convertToJson(parameters.taskTest), '[]') }}:
          # Set variable startTest if the build succeed so that we can run all the test tasks whether they are failed or not
            - script: |
                echo "##vso[task.setvariable variable=startTest]true"
              displayName: Start Test
            - ${{ each taskTestStep in parameters.taskTest }}:
              # Test - With coverage
              - ${{ if eq(startsWith(taskTestStep, 'ci:test'), true) }}:
                - task: Npm@1
                  displayName: npm run ${{ taskTestStep }}:coverage
                  inputs:
                    command: 'custom'
                    workingDir: ${{ parameters.buildDirectory }}
                    customCommand: 'run ${{ taskTestStep }}:coverage'
                  condition: and(succeededOrFailed(), eq(variables['startTest'], 'true'))
              # Test - No coverage
              - ${{ if eq(startsWith(taskTestStep, 'ci:test'), false) }}:
                  - task: Npm@1
                    displayName: npm run ${{ taskTestStep }}
                    inputs:
                      command: 'custom'
                      workingDir: ${{ parameters.buildDirectory }}
                      customCommand: 'run ${{ taskTestStep }}'
                    condition: and(succeededOrFailed(), eq(variables['startTest'], 'true'))

            # Test - Upload coverage results
            # Some webpacked file using externals introduce file name with quotes in them
            # and Istanbul's cobertura reporter doesn't escape them causing parse error when we publish
            # A quick fix to patch the file with sed. (See https://github.com/bcoe/c8/issues/302)
            - ${{ if eq(true, true) }}:
              - task: Bash@3
                displayName: 'Check for nyc/report directory'
                inputs:
                  targetType: 'inline'
                  workingDirectory: ${{ parameters.buildDirectory }}
                  script: |
                    test -d nyc/report && echo '##vso[task.setvariable variable=ReportDirExists;]true' || echo 'No nyc/report directory'
                condition: and(succeededOrFailed(), eq(variables['startTest'], 'true'))
              - task: Bash@3
                displayName: Patch Coverage Results
                inputs:
                  targetType: 'inline'
                  workingDirectory: ${{ parameters.buildDirectory }}/nyc/report
                  script: |
                    sed -e 's/\(filename=\".*[\\/]external .*\)"\(.*\)""/\1\&quot;\2\&quot;"/' cobertura-coverage.xml > cobertura-coverage-patched.xml
                condition: and(succeededOrFailed(), eq(variables['ReportDirExists'], 'true'))
              - task: PublishCodeCoverageResults@1
                displayName: Publish Code Coverage
                inputs:
                  codeCoverageTool: Cobertura
                  summaryFileLocation: ${{ parameters.buildDirectory }}/nyc/report/cobertura-coverage-patched.xml
                  reportDirectory: ${{ parameters.buildDirectory }}/nyc/report
                  failIfCoverageEmpty: true
                condition: and(succeededOrFailed(), eq(variables['ReportDirExists'], 'true'))

            # Test - Upload results
            - task: PublishTestResults@2
              displayName: Publish Test Results
              inputs:
                testResultsFormat: 'JUnit'
                testResultsFiles: '**/*junit-report.xml'
                searchFolder: ${{ parameters.buildDirectory }}/nyc
                mergeTestResults: false
              condition: and(succeededOrFailed(), eq(variables['startTest'], 'true'))
